---
title: "🧠 Algorithm 2: 푸드 파이트 대회"
date: 2025-02-04
categories: [Code, Algorithm]
tags: [Python, Programmers, Lv1]
---

# 푸드 파이트 대회

난이도: 프로그래머스 lv.1

### **문제 설명**

수웅이는 매달 주어진 음식을 빨리 먹는 푸드 파이트 대회를 개최합니다. 이 대회에서 선수들은 1대 1로 대결하며, 매 대결마다 음식의 종류와 양이 바뀝니다. 대결은 준비된 음식들을 일렬로 배치한 뒤, 한 선수는 제일 왼쪽에 있는 음식부터 오른쪽으로, 다른 선수는 제일 오른쪽에 있는 음식부터 왼쪽으로 순서대로 먹는 방식으로 진행됩니다. 중앙에는 물을 배치하고, 물을 먼저 먹는 선수가 승리하게 됩니다.

이때, 대회의 공정성을 위해 두 선수가 먹는 음식의 종류와 양이 같아야 하며, 음식을 먹는 순서도 같아야 합니다. 또한, 이번 대회부터는 칼로리가 낮은 음식을 먼저 먹을 수 있게 배치하여 선수들이 음식을 더 잘 먹을 수 있게 하려고 합니다. 이번 대회를 위해 수웅이는 음식을 주문했는데, 대회의 조건을 고려하지 않고 음식을 주문하여 몇 개의 음식은 대회에 사용하지 못하게 되었습니다.

예를 들어, 3가지의 음식이 준비되어 있으며, 칼로리가 적은 순서대로 1번 음식을 3개, 2번 음식을 4개, 3번 음식을 6개 준비했으며, 물을 편의상 0번 음식이라고 칭한다면, 두 선수는 1번 음식 1개, 2번 음식 2개, 3번 음식 3개씩을 먹게 되므로 음식의 배치는 "1223330333221"이 됩니다. 따라서 1번 음식 1개는 대회에 사용하지 못합니다.

수웅이가 준비한 음식의 양을 칼로리가 적은 순서대로 나타내는 정수 배열 `food`가 주어졌을 때, 대회를 위한 음식의 배치를 나타내는 문자열을 return 하는 solution 함수를 완성해주세요.

---

### 제한사항

- 2 ≤ `food`의 길이 ≤ 9
- 1 ≤ `food`의 각 원소 ≤ 1,000
- `food`에는 칼로리가 적은 순서대로 음식의 양이 담겨 있습니다.
- `food[i]`는 i번 음식의 수입니다.
- `food[0]`은 수웅이가 준비한 물의 양이며, 항상 1입니다.
- 정답의 길이가 3 이상인 경우만 입력으로 주어집니다.

---

### 입출력 예

| food | result |
| --- | --- |
| [1, 3, 4, 6] | "1223330333221" |
| [1, 7, 1, 2] | "111303111" |

---

### 문제 풀이

- 이 문제를 풀기 위해 2가지 접근을 시도 했었다
- 1번째는 테이블을 queue로 가운데 물 ‘0’로 초기화해서 앞 뒤로 append, appendleft로 음식들을 추가하는 방법
- 2번째는 테이블은 대칭이니까 절반으로 갈라서 절반만 구해서 완성 시키는 법
- 1번째 방법은 칼로리가 큰 것 먼저 밀어 넣되 좌,우,좌,우 반복적으로 넣어줘야 된다는 점이 구현하기 복잡했다. count 변수를 만들어서 짝수면 왼쪽, 홀수면 오른쪽에 append 해줬는데 이럴 경우 코드가 너무 길어졌다.
- 또한, 자세히 보면 food 리스트는 인덱스 자체가 음식의 칼로리를 반환해주기 때문에 [물, 1칼로리, 2칼로리, 3칼로리 … n칼로리] 칼로리로 테이블을 채워 넣어야 할 때 위 방식으로 하면 리버스 반복문까지 고려해야 되어서 복잡하다
- 따라서, 2번째 방법으로 절반 갈라서 쉽게 풀수 있었다.

```python
def solution(food):
    
    # 가운데 물 0을 기준으로 대칭
    # 한쪽만 구한다음 half + 0 + reversed_half
    # food의 홀수 원소는 -1
    # 한쪽만 구하기 위해서 food 원소 *1/2
    
    half_food = []
    
    # 0번째 인덱스 물을 제외한 1번째 인덱스부터 순회
    for idx in range(1, len(food)):
        # 홀수면 -1
        if food[idx] % 2 != 0:
            # 테이블 반쪽만 구할거라 나누기 2
            half_food.append((food[idx] - 1)//2)
        else:
            half_food.append(food[idx]//2)
    
    # 반쪽 테이블 리스트
    half_table = []
    
    # 음식 칼로리대로 갯수를 테이블에 나열
    for idx, foo in enumerate(half_food):
        for _ in range(foo):
            half_table.append(idx+1)
    
    # 반대쪽 반쪽 테이블 리스트
    reversed_half = list(reversed(half_table))
    
    # 가운데 물 추가한 최종 테이블
    final_table = half_table + [0] + reversed_half
    
    # 정수 리스트에서 최종 문자열 형태로
    answer = "".join(map(str, final_table))
    
    return answer
```