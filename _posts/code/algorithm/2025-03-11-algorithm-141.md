---
title: "ğŸ§  Algorithm 141: ì¿¼ë“œì••ì¶• í›„ ê°œìˆ˜ ì„¸ê¸°"
date: 2025-03-11
categories: [Code, Algorithm]
tags: [Python, Programmers, Lv2]
---

# ì¿¼ë“œì••ì¶• í›„ ê°œìˆ˜ ì„¸ê¸°

ë‚œì´ë„: í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ lv.2
ìœ í˜•: BFS, DFS

### **ë¬¸ì œ ì„¤ëª…**

0ê³¼ 1ë¡œ ì´ë£¨ì–´ì§„ 2nÂ x 2nÂ í¬ê¸°ì˜ 2ì°¨ì› ì •ìˆ˜ ë°°ì—´ arrì´ ìˆìŠµë‹ˆë‹¤. ë‹¹ì‹ ì€ ì´ arrì„Â [ì¿¼ë“œ íŠ¸ë¦¬](https://en.wikipedia.org/wiki/Quadtree)ì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ì••ì¶•í•˜ê³ ì í•©ë‹ˆë‹¤. êµ¬ì²´ì ì¸ ë°©ì‹ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

1. ë‹¹ì‹ ì´ ì••ì¶•í•˜ê³ ì í•˜ëŠ” íŠ¹ì • ì˜ì—­ì„ Së¼ê³  ì •ì˜í•©ë‹ˆë‹¤.
2. ë§Œì•½ S ë‚´ë¶€ì— ìˆëŠ” ëª¨ë“  ìˆ˜ê°€ ê°™ì€ ê°’ì´ë¼ë©´, Së¥¼ í•´ë‹¹ ìˆ˜ í•˜ë‚˜ë¡œ ì••ì¶•ì‹œí‚µë‹ˆë‹¤.
3. ê·¸ë ‡ì§€ ì•Šë‹¤ë©´, Së¥¼ ì •í™•íˆ 4ê°œì˜ ê· ì¼í•œ ì •ì‚¬ê°í˜• ì˜ì—­(ì…ì¶œë ¥ ì˜ˆë¥¼ ì°¸ê³ í•´ì£¼ì‹œê¸° ë°”ëë‹ˆë‹¤.)ìœ¼ë¡œ ìª¼ê°  ë’¤, ê° ì •ì‚¬ê°í˜• ì˜ì—­ì— ëŒ€í•´ ê°™ì€ ë°©ì‹ì˜ ì••ì¶•ì„ ì‹œë„í•©ë‹ˆë‹¤.

arrì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤. ìœ„ì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ arrì„ ì••ì¶•í–ˆì„ ë•Œ, ë°°ì—´ì— ìµœì¢…ì ìœ¼ë¡œ ë‚¨ëŠ” 0ì˜ ê°œìˆ˜ì™€ 1ì˜ ê°œìˆ˜ë¥¼ ë°°ì—´ì— ë‹´ì•„ì„œ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.

---

### ì œí•œì‚¬í•­

- arrì˜ í–‰ì˜ ê°œìˆ˜ëŠ” 1 ì´ìƒ 1024 ì´í•˜ì´ë©°, 2ì˜ ê±°ë“­ ì œê³±ìˆ˜ í˜•íƒœë¥¼ í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì¦‰, arrì˜ í–‰ì˜ ê°œìˆ˜ëŠ” 1, 2, 4, 8, ..., 1024 ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤.
    - arrì˜ ê° í–‰ì˜ ê¸¸ì´ëŠ” arrì˜ í–‰ì˜ ê°œìˆ˜ì™€ ê°™ìŠµë‹ˆë‹¤. ì¦‰, arrì€ ì •ì‚¬ê°í˜• ë°°ì—´ì…ë‹ˆë‹¤.
    - arrì˜ ê° í–‰ì— ìˆëŠ” ëª¨ë“  ê°’ì€ 0 ë˜ëŠ” 1 ì…ë‹ˆë‹¤.

---

### ì…ì¶œë ¥ ì˜ˆ

| arr | result |
| --- | --- |
| `[[1,1,0,0],[1,0,0,0],[1,0,0,1],[1,1,1,1]]` | `[4,9]` |
| `[[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1],[0,1,0,0,1,1,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,1,0,0,1],[0,0,0,0,1,1,1,1]]` | `[10,15]` |

---

### ë¬¸ì œ í’€ì´

```python
# ì§ìˆ˜xì§ìˆ˜ ì—ì„œ ì••ì¶•ëª»í•˜ë©´ ê·¸ê±¸ 4êµ¬ê°„ìœ¼ë¡œ ìª¼ê°œì„œ ë‹¤ì‹œ ì••ì¶•í•¨

# ì••ì¶•ì€ í•´ë‹¹ êµ¬ê°„ì„ ì™„ì „ íƒìƒ‰í•´ì„œ ì „ë¶€ ê°™ìœ¼ë©´ ì••ì¶• í•˜ë‚˜ë¼ë„ ë‹¤ë¥´ë©´ ì‹¤íŒ¨

# bfs ëŠë‚Œ
from collections import deque

def solution(arr):
    n = len(arr)
    count = [0,0]
    
    boundaries = deque([(0, n, 0, n)])
    
    while boundaries:
        row_from, row_to, col_from, col_to = boundaries.popleft()
        first_num = arr[row_from][col_from]
        is_compressed = True
        
        for i in range(row_from, row_to):
            for j in range(col_from, col_to):
                if arr[i][j] != first_num:
                    is_compressed = False
                    break
                    
        if is_compressed:
            count[first_num] += 1
        
        else:
            row_middle = (row_from + row_to) // 2
            col_middle = (col_from + col_to) // 2
            
            a = (row_from, row_middle, col_from, col_middle)
            b = (row_middle, row_to, col_from, col_middle)
            c = (row_from, row_middle, col_middle, col_to)
            d = (row_middle, row_to, col_middle, col_to)
            
            boundaries.extend([a,b,c,d])
        
        
    return count
```