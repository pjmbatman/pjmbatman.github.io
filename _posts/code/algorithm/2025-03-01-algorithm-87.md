---
title: "🧠 Algorithm 87: 다음 큰 숫자"
date: 2025-03-01
categories: [Code, Algorithm]
tags: [Python, Programmers, Lv2]
---

# 다음 큰 숫자

난이도: 프로그래머스 lv.2

### **문제 설명**

자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다.

- 조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다.
- 조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다.
- 조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다.

예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다.

자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요.

### 제한 사항

- n은 1,000,000 이하의 자연수 입니다.

---

### 입출력 예

| n | result |
| --- | --- |
| 78 | 83 |
| 15 | 23 |

---

### 문제 풀이

```python
"""
예 10011010
1의 갯수가 같아야하며 기존 수 보다 값이 커야되면, 0과 1을 바꾸되 1이 0 최소한 한 개 오른쪽에 있어야한다
반례: 111100 이런 값이면 1과0을 한 개 바꿔도 111001 이런식으로 더 값이 작아져버림
110101 같은 예시가 있다면 110110 처럼 1이 0오른쪽에 있다면 0오른쪽에 있는 1을 0으로 바꿔버리고 가장 작은 자릿수에 있는 0을 1로 바꾸면 된다

11001000100 이런 예시가 있다면, (오른쪽에서부터) 처음 나오는 1을 기준으로 그 처음 나오는 1만 0으로 바꾸고 그 다음 나오는 (그래야 가장 작은 수)0을 1로 바꾸면 된다

만약 0이 없는 모두 1로 가득한 수라면 -> 1111 -> 10111
두번째 인덱스에 0을 넣고 뒤로 밀면 된다
1이 0오른쪽에 없다면 -> 11100 ->101100
이것도 마찬가지로 두번째 인덱스에 0을 넣고 뒤로 밀면 된다

위 조건들을 모두 코드로 구현하면 복잡하므로,

자연수 -> 2진수 변환 -> check = count("1") 저장 -> 자연수 늘려가면서 count("1") == check 라면, 그 자연수 반환

위 방법이 가장 간단할 것. 대신에 111111111이런수라면 10111111111 까지 탐색해야하는데 이렇게되면 너무 오래 걸릴거 같음

아래 방법을 해보고 안되며 위 조건 식 나열해서 하는 식으로 플랜
"""

def solution(n):
    
    bin_num = bin(n)
    count = bin_num.count("1")
        
    while True:
        n += 1
        bin_num = bin(n)
        if bin_num.count("1") == count:
            return n
        
```