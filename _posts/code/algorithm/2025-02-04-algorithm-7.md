---
title: "🧠 Algorithm 7: 가장 가까운 같은 글자"
date: 2025-02-04
categories: [Code, Algorithm]
tags: [Python, Programmers, Lv1]
---

# 가장 가까운 같은 글자

난이도: 프로그래머스 lv.1

### **문제 설명**

문자열 `s`가 주어졌을 때, `s`의 각 위치마다 자신보다 앞에 나왔으면서, 자신과 가장 가까운 곳에 있는 같은 글자가 어디 있는지 알고 싶습니다.

예를 들어, `s`="banana"라고 할 때,  각 글자들을 왼쪽부터 오른쪽으로 읽어 나가면서 다음과 같이 진행할 수 있습니다.

- b는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
- a는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
- n은 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
- a는 자신보다 두 칸 앞에 a가 있습니다. 이는 2로 표현합니다.
- n도 자신보다 두 칸 앞에 n이 있습니다. 이는 2로 표현합니다.
- a는 자신보다 두 칸, 네 칸 앞에 a가 있습니다. 이 중 가까운 것은 두 칸 앞이고, 이는 2로 표현합니다.

따라서 최종 결과물은 [-1, -1, -1, 2, 2, 2]가 됩니다.

문자열 `s`이 주어질 때, 위와 같이 정의된 연산을 수행하는 함수 solution을 완성해주세요.

---

### 제한사항

- 1 ≤ `s`의 길이 ≤ 10,000
    - `s`은 영어 소문자로만 이루어져 있습니다.

---

### 입출력 예

| s | result |
| --- | --- |
| "banana" | [-1, -1, -1, 2, 2, 2] |
| "foobar" | [-1, -1, 1, -1, -1, -1] |

---

### 문제 풀이

- 푸는 방법은 떠오른 건 일단 딕셔너리를 사용하는 것과 집합을 사용하는 것
- 딕셔너리를 사용한다면 letter:가장 최근에 등장한 index
- 집합을 사용한다면 중복되는 letter가 제거되는 점을 활용
- letter를 순회할 때 set에서 발견되면 처음 나오는 문자 -1 처리와 set에서 원소 삭제
- 이후, set에서 원소를 삭제 했기 때문에 set에서 발견되지 않으면 이미 나온 letter 라는 뜻
- 이미 나온 letter의 경우 가장 근접한 같은 letter와의 거리를 찾기 위해 현 letter의 위치에서 역순으로 순회
- 가장 빨리 같은 letter의 index를 이용해 거리 계산

```python
def solution(s):
    # 문자열 s에서 처음 나오는 문자는 -1
    # 그 뒤에 똑같은 문자가 나온다면 처음 나온 문자와의 거리로 표현
    
    save_list = []
    
    # 중복 제거
    set_s = set(s)
    
    for idx, letter in enumerate(s):
        # 중복 제거한 집합에서 발견된다면 -1 저장하고 집합에서 해당 letter 삭제
        if letter in set_s:
            set_s.discard(letter)
            save_list.append(-1)
        # 집합에서 발견이 안되면 처음 나온 letter가 아니라는 뜻   
        else:
            # 현재 letter 기준으로 역순으로 순회해서 가장 가까운 동일한 letter와의 거리를 저장
            for i in range(idx-1, -1, -1):
                if letter == s[i]:
                    distance = idx - i
                    save_list.append(distance)
                    break
                
    return save_list
```