---
title: "ğŸ§  Algorithm 143: ê±°ë¦¬ë‘ê¸° í™•ì¸í•˜ê¸°"
date: 2025-03-11
categories: [Code, Algorithm]
tags: [Python, Programmers, Lv2]
---

# ê±°ë¦¬ë‘ê¸° í™•ì¸í•˜ê¸°

ë‚œì´ë„: í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ lv.2
ìœ í˜•: êµ¬í˜„

### **ë¬¸ì œ ì„¤ëª…**

ê°œë°œìë¥¼ í¬ë§í•˜ëŠ” ì£ ë¥´ë””ê°€ ì¹´ì¹´ì˜¤ì— ë©´ì ‘ì„ ë³´ëŸ¬ ì™”ìŠµë‹ˆë‹¤.

ì½”ë¡œë‚˜ ë°”ì´ëŸ¬ìŠ¤ ê°ì—¼ ì˜ˆë°©ì„ ìœ„í•´ ì‘ì‹œìë“¤ì€ ê±°ë¦¬ë¥¼ ë‘¬ì„œ ëŒ€ê¸°ë¥¼ í•´ì•¼í•˜ëŠ”ë° ê°œë°œ ì§êµ° ë©´ì ‘ì¸ ë§Œí¼

ì•„ë˜ì™€ ê°™ì€ ê·œì¹™ìœ¼ë¡œ ëŒ€ê¸°ì‹¤ì— ê±°ë¦¬ë¥¼ ë‘ê³  ì•‰ë„ë¡ ì•ˆë‚´í•˜ê³  ìˆìŠµë‹ˆë‹¤.

> ëŒ€ê¸°ì‹¤ì€ 5ê°œì´ë©°, ê° ëŒ€ê¸°ì‹¤ì€ 5x5 í¬ê¸°ì…ë‹ˆë‹¤.ê±°ë¦¬ë‘ê¸°ë¥¼ ìœ„í•˜ì—¬ ì‘ì‹œìë“¤ ë¼ë¦¬ëŠ” ë§¨í•´íŠ¼ ê±°ë¦¬1ê°€ 2 ì´í•˜ë¡œ ì•‰ì§€ ë§ì•„ ì£¼ì„¸ìš”.ë‹¨ ì‘ì‹œìê°€ ì•‰ì•„ìˆëŠ” ìë¦¬ ì‚¬ì´ê°€ íŒŒí‹°ì…˜ìœ¼ë¡œ ë§‰í˜€ ìˆì„ ê²½ìš°ì—ëŠ” í—ˆìš©í•©ë‹ˆë‹¤.
> 

ì˜ˆë¥¼ ë“¤ì–´,

[ì œëª© ì—†ìŒ](%E1%84%80%E1%85%A5%E1%84%85%E1%85%B5%E1%84%83%E1%85%AE%E1%84%80%E1%85%B5%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%201b325b0c2ed980e89b74dcf566cfb183/%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%201b325b0c2ed980489ff2c2424c35d82f.csv)

5ê°œì˜ ëŒ€ê¸°ì‹¤ì„ ë³¸ ì£ ë¥´ë””ëŠ” ê° ëŒ€ê¸°ì‹¤ì—ì„œ ì‘ì‹œìë“¤ì´ ê±°ë¦¬ë‘ê¸°ë¥¼ ì˜ ê¸°í‚¤ê³  ìˆëŠ”ì§€ ì•Œê³  ì‹¶ì–´ì¡ŒìŠµë‹ˆë‹¤. ìë¦¬ì— ì•‰ì•„ìˆëŠ” ì‘ì‹œìë“¤ì˜ ì •ë³´ì™€ ëŒ€ê¸°ì‹¤ êµ¬ì¡°ë¥¼ ëŒ€ê¸°ì‹¤ë³„ë¡œ ë‹´ì€ 2ì°¨ì› ë¬¸ìì—´ ë°°ì—´Â `places`ê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤. ê° ëŒ€ê¸°ì‹¤ë³„ë¡œ ê±°ë¦¬ë‘ê¸°ë¥¼ ì§€í‚¤ê³  ìˆìœ¼ë©´ 1ì„, í•œ ëª…ì´ë¼ë„ ì§€í‚¤ì§€ ì•Šê³  ìˆìœ¼ë©´ 0ì„ ë°°ì—´ì— ë‹´ì•„ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ì£¼ì„¸ìš”.

---

### ì œí•œì‚¬í•­

- `places`ì˜ í–‰ ê¸¸ì´(ëŒ€ê¸°ì‹¤ ê°œìˆ˜) = 5
    - `places`ì˜ ê° í–‰ì€ í•˜ë‚˜ì˜ ëŒ€ê¸°ì‹¤ êµ¬ì¡°ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
- `places`ì˜ ì—´ ê¸¸ì´(ëŒ€ê¸°ì‹¤ ì„¸ë¡œ ê¸¸ì´) = 5
- `places`ì˜ ì›ì†ŒëŠ”Â `P`,`O`,`X`ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì…ë‹ˆë‹¤.
    - `places`Â ì›ì†Œì˜ ê¸¸ì´(ëŒ€ê¸°ì‹¤ ê°€ë¡œ ê¸¸ì´) = 5
    - `P`ëŠ” ì‘ì‹œìê°€ ì•‰ì•„ìˆëŠ” ìë¦¬ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.
    - `O`ëŠ” ë¹ˆ í…Œì´ë¸”ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.
    - `X`ëŠ” íŒŒí‹°ì…˜ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.
- ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì§€ëŠ” 5ê°œ ëŒ€ê¸°ì‹¤ì˜ í¬ê¸°ëŠ” ëª¨ë‘ 5x5 ì…ë‹ˆë‹¤.
- return ê°’ í˜•ì‹
    - 1ì°¨ì› ì •ìˆ˜ ë°°ì—´ì— 5ê°œì˜ ì›ì†Œë¥¼ ë‹´ì•„ì„œ return í•©ë‹ˆë‹¤.
    - `places`ì— ë‹´ê²¨ ìˆëŠ” 5ê°œ ëŒ€ê¸°ì‹¤ì˜ ìˆœì„œëŒ€ë¡œ, ê±°ë¦¬ë‘ê¸° ì¤€ìˆ˜ ì—¬ë¶€ë¥¼ ì°¨ë¡€ëŒ€ë¡œ ë°°ì—´ì— ë‹´ìŠµë‹ˆë‹¤.
    - ê° ëŒ€ê¸°ì‹¤ ë³„ë¡œ ëª¨ë“  ì‘ì‹œìê°€ ê±°ë¦¬ë‘ê¸°ë¥¼ ì§€í‚¤ê³  ìˆìœ¼ë©´ 1ì„, í•œ ëª…ì´ë¼ë„ ì§€í‚¤ì§€ ì•Šê³  ìˆìœ¼ë©´ 0ì„ ë‹´ìŠµë‹ˆë‹¤.

---

### ì…ì¶œë ¥ ì˜ˆ

| places | result |
| --- | --- |
| `[["POOOP", "OXXOX", "OPXPX", "OOXOX", "POXXP"], ["POOPX", "OXPXP", "PXXXO", "OXXXO", "OOOPP"], ["PXOPX", "OXOXP", "OXPOX", "OXXOP", "PXPOX"], ["OOOXX", "XOOOX", "OOOXX", "OXOOX", "OOOOO"], ["PXPXP", "XPXPX", "PXPXP", "XPXPX", "PXPXP"]]` | [1, 0, 1, 1, 1] |

---

### ë¬¸ì œ í’€ì´

- ì½”ë“œ 1ì€ ëŒ€ê°ì„  ì¡°ê±´ì„ ë„ˆë¬´ ë³µì¡í•˜ê²Œ ìƒê°í–ˆìŒ
- ì½”ë“œ 2ëŠ” ëŒ€ê°ì„ ì€ ì‚¬ì‹¤ ê·¸ëƒ¥ x1y2, x2y1 í•˜ë©´ ë˜ëŠ” ê²ƒì„ ë°˜ì˜

```python
def solution(places):
    m, n = 5, 5
    result = []
    
    for place in places:
        Ps = []
        # Pì˜ ìœ„ì¹˜ ìˆ˜ì§‘
        for i in range(n):
            for j in range(m):
                if place[i][j] == 'P':
                    Ps.append([i, j])
        
        # ë§¨í•˜íŠ¼ ê±°ë¦¬ ì²´í¬
        is_valid = True
        for idx, P in enumerate(Ps):
            i, j = P
            for other in Ps[idx+1:]:  # ì¤‘ë³µ ì²´í¬ ë°©ì§€
                new_i, new_j = other
                dist = abs(new_i - i) + abs(new_j - j)
                
                if dist == 1:  # ë°”ë¡œ ì¸ì ‘
                    is_valid = False
                    break
                elif dist == 2:  # ê±°ë¦¬ 2
                    # ìˆ˜í‰ ì²´í¬
                    if i == new_i:
                        mid_j = (j + new_j) // 2
                        if place[i][mid_j] != 'X':
                            is_valid = False
                            break
                    # ìˆ˜ì§ ì²´í¬
                    elif j == new_j:
                        mid_i = (i + new_i) // 2
                        if place[mid_i][j] != 'X':
                            is_valid = False
                            break
                    # ëŒ€ê°ì„  ì²´í¬
                    else:
                        if new_i < i and new_j > j:  # ì™¼ìª½ ì•„ë˜ -> ì˜¤ë¥¸ìª½ ìœ„
                            if place[i][new_j] != 'X' or place[new_i][j] != 'X':
                                is_valid = False
                                break
                        elif new_i > i and new_j > j:  # ì™¼ìª½ ìœ„ -> ì˜¤ë¥¸ìª½ ì•„ë˜
                            if place[i][new_j] != 'X' or place[new_i][j] != 'X':
                                is_valid = False
                                break
                        elif new_i < i and new_j < j:  # ì˜¤ë¥¸ìª½ ì•„ë˜ -> ì™¼ìª½ ìœ„
                            if place[i][new_j] != 'X' or place[new_i][j] != 'X':
                                is_valid = False
                                break
                        elif new_i > i and new_j < j:  # ì˜¤ë¥¸ìª½ ìœ„ -> ì™¼ìª½ ì•„ë˜
                            if place[i][new_j] != 'X' or place[new_i][j] != 'X':
                                is_valid = False
                                break
            if not is_valid:
                break
        
        result.append(1 if is_valid else 0)
    
    return result
```

```python
def solution(places):
    def check_distance(place):
        # ëª¨ë“  P(ì‘ì‹œì)ì˜ ìœ„ì¹˜ë¥¼ ì°¾ìŒ
        people = []
        for i in range(5):
            for j in range(5):
                if place[i][j] == 'P':
                    people.append((i, j))
        
        # ëª¨ë“  ì‘ì‹œì ìŒì— ëŒ€í•´ ê±°ë¦¬ ì²´í¬
        for i in range(len(people)):
            for j in range(i + 1, len(people)):
                x1, y1 = people[i]
                x2, y2 = people[j]
                
                # ë§¨í•´íŠ¼ ê±°ë¦¬ ê³„ì‚°
                manhattan = abs(x1 - x2) + abs(y1 - y2)
                
                # ê±°ë¦¬ê°€ 2 ì´í•˜ì¸ ê²½ìš° ì²´í¬ í•„ìš”
                if manhattan <= 2:
                    # ê±°ë¦¬ê°€ 1ì´ë©´ ë¬´ì¡°ê±´ ìœ„ë°˜
                    if manhattan == 1:
                        return False
                    # ê±°ë¦¬ê°€ 2ì¸ ê²½ìš° íŒŒí‹°ì…˜ í™•ì¸
                    elif manhattan == 2:
                        # ìˆ˜í‰ìœ¼ë¡œ 2ì¹¸ ë–¨ì–´ì§„ ê²½ìš°
                        if x1 == x2:
                            if place[x1][min(y1, y2) + 1] != 'X':
                                return False
                        # ìˆ˜ì§ìœ¼ë¡œ 2ì¹¸ ë–¨ì–´ì§„ ê²½ìš°
                        elif y1 == y2:
                            if place[min(x1, x2) + 1][y1] != 'X':
                                return False
                        # ëŒ€ê°ì„ ì¸ ê²½ìš°
                        else:
                            # ë‘ ê²½ë¡œ ëª¨ë‘ íŒŒí‹°ì…˜ì´ ìˆì–´ì•¼ í•¨
                            if not (place[x1][y2] == 'X' and place[x2][y1] == 'X'):
                                return False
        return True
    
    # ê° ëŒ€ê¸°ì‹¤ë³„ë¡œ ì²´í¬
    result = []
    for place in places:
        if check_distance(place):
            result.append(1)
        else:
            result.append(0)
    
    return result

# í…ŒìŠ¤íŠ¸
places = [
    ["POOOP", "OXXOX", "OPXPX", "OOXOX", "POXXP"],
    ["POOPX", "OXPXP", "PXXXO", "OXXXO", "OOOPP"],
    ["PXOPX", "OXOXP", "OXPOX", "OXXOP", "PXPOX"],
    ["OOOXX", "XOOOX", "OOOXX", "OXOOX", "OOOOO"],
    ["PXPXP", "XPXPX", "PXPXP", "XPXPX", "PXPXP"]
]
print(solution(places))  # [1, 0, 1, 1, 1]
```