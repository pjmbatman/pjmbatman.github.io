---
title: "🧠 Algorithm 5: 3 x n 타일링"
date: 2025-02-27
categories: [Code, Algorithm]
tags: [Python, Programmers, Lv2]
---

# 3 x n 타일링

생성 일시: 2025년 2월 27일 오전 1:48
난이도: 프로그래머스 lv.2

### **문제 설명**

가로 길이가 2이고 세로의 길이가 1인 직사각형 모양의 타일이 있습니다. 이 직사각형 타일을 이용하여 세로의 길이가 3이고 가로의 길이가 n인 바닥을 가득 채우려고 합니다. 타일을 채울 때는 다음과 같이 2가지 방법이 있습니다

- 타일을 가로로 배치 하는 경우
- 타일을 세로로 배치 하는 경우

예를들어서 n이 8인 직사각형은 다음과 같이 채울 수 있습니다.

![](https://i.imgur.com/zBW7peI.png)

직사각형의 가로의 길이 n이 매개변수로 주어질 때, 이 직사각형을 채우는 방법의 수를 return 하는 solution 함수를 완성해주세요.

### 제한사항

- 가로의 길이 n은 5,000이하의 자연수 입니다.
- 경우의 수가 많아 질 수 있으므로, 경우의 수를 1,000,000,007으로 나눈 나머지를 return해주세요.

### 입출력 예

| n | result |
| --- | --- |
| 4 | 11 |

---

### 문제 풀이

- 이전 계산 결과를 저장하여 중복 계산을 줄이는 동적 계획법을 활용했기 때문입니다.

- 2xn 타일링과 달리 세로 길이가 3이면 특정 길이 마다 고유의 패턴이 등장한다
- 길이 4부터 2의 배수 단위로 4,6,8,10… 일 때마다 새로운 패턴이 2개씩 추가된다
- 그 특수의 수를 제외하고는 2칸 마다 길이 2칸짜리 3개의 패턴이 생기므로 dp[n-2]*3
- 그리고 2의 배수 단위로 새로운 패턴이 2개씩 추가되는데 $\sum_{i=4}^{n}$dp[n-i] * 2로 해석할 수있다

```python
"""
n= 2,4 -> 3, 11

2의 배수 일 때 + 4의 배수 일 때

인덱스가 2의 배수로 올라가니 나중에 매핑 해야됨

n -> (n-2)*3 + (n-4)*2

2칸 붙일 때의 경우의 수는 2칸 이전까지의 경우의 수와 2칸 붙이는 경우의 수를 곱하면 된다 = (n-2)*3

4칸 붙이는 경우의수는 4칸 이전까지의 경우의 수와 4칸 붙이는 경우의 수(11번)에서 중복되는 2칸2칸 붙이는 경우의 수(9번)를 빼면된다 = (n-4)*2

즉 점화식은-> dp[n] = dp[n-2]*3 + dp[n-4]*2 + dp[n-6]*2 ...
"""

def solution(n):
    dp = [0]*(n+1)
    dp[2] = 4
    dp[4] = 11
    MOD = 1_000_000_007
    for i in range(6, n+1, 2):
        dp[i] = (dp[i-2]*3 + sum(dp[:i-4+1])*2) % MOD
        
    return dp[n]
```